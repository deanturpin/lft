# Critical Bug Fixes: Duplicate Order Prevention

**Date:** 2026-01-13
**Severity:** CRITICAL - Caused multiple simultaneous positions on same asset
**Status:** FIXED (not yet committed)

## Summary

Fixed three interconnected bugs that allowed duplicate orders to be placed for the same symbol within minutes of each other. Most severe case: 3 simultaneous ETH/USD positions opened at 15:11:41, 15:12:39, and 15:13:38 (58-59 seconds apart).

## Root Cause Analysis

### The Perfect Storm

1. **Fast order fills** - Crypto market orders fill in < 1 second
2. **Alpaca API lag** - `/v2/positions` endpoint has 60-90 second delay showing new crypto positions
3. **Aggressive cleanup** - Code removed tracking entries if position wasn't in API response
4. **Missing guards** - Only checked API-derived state, not persistent local tracking

### Timeline of Failure

```
15:11:41 - Cycle 1:
  ‚îú‚îÄ Place ETH/USD order ($1000)
  ‚îú‚îÄ Order fills instantly
  ‚îú‚îÄ Position opens in Alpaca
  ‚îî‚îÄ Local tracking: position_strategies["ETH/USD"] = "mean_reversion"

15:12:39 - Cycle 2 (58 seconds later):
  ‚îú‚îÄ API call: get_positions() ‚Üí DOESN'T include ETH/USD (lag!)
  ‚îú‚îÄ Cleanup loop: "ETH/USD not in API, must be stale" ‚Üí ERASES tracking
  ‚îú‚îÄ Trade check: No API position, no local tracking ‚Üí "Safe to trade"
  ‚îî‚îÄ Place ANOTHER ETH/USD order ($1000) ‚ùå

15:13:38 - Cycle 3 (59 seconds later):
  ‚îî‚îÄ Same sequence ‚Üí THIRD duplicate order ‚ùå

Result: 3 simultaneous $1000 ETH/USD positions
```

## Three Bugs Fixed

### Bug 1: Non-Unique `client_order_id`

**Location:** `encode_client_order_id()` function (lines 77-93)

**Problem:**

```cpp
// OLD: Same ID for all orders with same strategy/params
"momentum|tp:2.0|sl:-5.0|ts:30.0"
```

When placing orders for TLT, SPY, etc. with same strategy, all got identical `client_order_id`. Alpaca rejected with:

```
{"code":40010001,"message":"client_order_id must be unique"}
```

**Fix:**

```cpp
// NEW: Include symbol + millisecond timestamp
"TLT_momentum_1768317100944|tp:2.0|sl:-5.0|ts:30.0"
```

Updated `decode_strategy()` to parse new format correctly.

---

### Bug 2: Aggressive Cleanup Loop

**Location:** Lines 1255-1292 (cleanup loop before trading logic)

**Problem:**

```cpp
// OLD: Remove from tracking if not in API response
for (auto it = position_strategies.begin(); it != position_strategies.end();) {
  if (not api_positions.contains(it->first)) {
    it = position_strategies.erase(it);  // ‚ùå Too aggressive!
```

Intended to clean up rejected/canceled orders, but also removed legitimate pending positions that hadn't appeared in API yet due to lag.

**Fix:**

```cpp
// NEW: 5-minute grace period for recently entered positions
auto five_minutes_ago = now - std::chrono::minutes{5};
auto recently_entered = position_entry_times.contains(symbol) and
                       position_entry_times[symbol] > five_minutes_ago;

// Only erase if position doesn't exist AND wasn't recently entered
if (not api_positions.contains(symbol) and not recently_entered) {
  it = position_strategies.erase(it);
}
```

Now protects entries for 5 minutes regardless of API state. This handles Alpaca's 60-90 second lag while still cleaning up truly stale entries.

---

### Bug 3: Missing Duplicate Guards

**Location:**

- Lines 1331-1343 (trade entry check)
- Lines 1457, 1468 (immediate tracking after order placement)

**Problem:**

```cpp
// OLD: Only checked API-derived state
if (not symbols_in_use.contains(symbol)) {
  place_order();  // ‚ùå symbols_in_use destroyed each cycle!
}
```

`symbols_in_use` is a local variable recreated each cycle. If API hasn't updated yet, symbol appears "available".

**Fix - Part A (Two-layer guard):**

```cpp
// NEW: Check both API state AND persistent local tracking
if (not symbols_in_use.contains(symbol) and
    not position_strategies.contains(symbol)) {
  place_order();  // ‚úì Protected by persistent map
}
```

**Fix - Part B (Immediate tracking):**

```cpp
// After successful order placement:
position_strategies[symbol] = strategy;
position_entry_times[symbol] = now;
symbols_in_use.insert(symbol);  // ‚Üê NEW: Within-cycle protection

// Prevents multiple strategies from trading same symbol in same cycle
```

## How The Fix Works

### Three Layers of Protection

1. **Within-cycle protection** (lines 1457, 1468)
   - Immediately add symbol to `symbols_in_use` after placing order
   - Prevents multiple strategies in same cycle from duplicating

2. **Cross-cycle protection** (lines 1331-1343)
   - Check persistent `position_strategies` map (survives across cycles)
   - Not just `symbols_in_use` (which is transient/API-dependent)

3. **Grace period protection** (lines 1255-1292)
   - 5-minute window before cleanup can remove tracking
   - Handles Alpaca API lag gracefully

### Example: No More Duplicates

```
15:11:41 - Cycle 1:
  ‚îú‚îÄ Place ETH/USD order
  ‚îú‚îÄ position_strategies["ETH/USD"] = "mean_reversion"
  ‚îú‚îÄ position_entry_times["ETH/USD"] = 15:11:41
  ‚îî‚îÄ symbols_in_use.insert("ETH/USD")

15:12:39 - Cycle 2:
  ‚îú‚îÄ Cleanup check: position_entry_times shows 15:11:41 (58 seconds ago)
  ‚îú‚îÄ 58 seconds < 5 minutes ‚Üí KEEP in position_strategies ‚úì
  ‚îú‚îÄ Trade check: position_strategies.contains("ETH/USD") ‚Üí TRUE
  ‚îî‚îÄ BLOCKED - no duplicate order! ‚úì

15:13:38 - Cycle 3:
  ‚îî‚îÄ Same protection - still blocked ‚úì
```

## Future Improvements (TODOs in code)

1. **Increase grace period** - Consider 30-60 minutes for stronger protection
2. **Persistent state file** - Write `position_strategies` to disk (survive bot restarts)
3. **Hard limit** - Add "max trades per symbol per session" safety net
4. **Audit trail** - Track all orders in SQLite database for forensic analysis

## Testing Recommendations

1. Monitor console output for "üìä OPEN POSITIONS" table accuracy
2. Verify no duplicate orders appear in subsequent trading sessions
3. Check that legitimate position cleanup still works after 5+ minutes
4. Test bot restart scenario (currently loses tracking - known limitation)

## Files Modified

- `src/lft.cxx` - All three fixes + comprehensive documentation
- `src/alpaca_client.cxx` - No changes
- `include/alpaca_client.h` - No changes

## Not Committed

Per user instruction, changes are built and documented but NOT committed to git.

---

# Bug Analysis: Program Freeze at 19:40 GMT (2026-01-13)

**Time:** 19:40 GMT (14:40 ET / 2:40 PM ET)
**Impact:** Missed EOD auto-liquidation, required manual closure of 20 positions at 3:59 PM ET
**Status:** IDENTIFIED, not yet fixed

## Symptom

- Program froze during normal trading hours at 19:40 GMT
- Never reached EOD auto-liquidation scheduled for 3:57 PM ET (19:57 GMT)
- User had to manually close all 20 positions with 1 minute to spare before market close

## Root Cause

**Missing read timeout on HTTP client calls to Alpaca API**

The code sets `client.set_connection_timeout(10)` but never sets `client.set_read_timeout()`.

### Technical Explanation

HTTP operations have two distinct timeout types:

1. **Connection timeout**: How long to wait for TCP handshake (CONFIGURED: 10s ‚úÖ)
2. **Read timeout**: How long to wait for response body after connection established (NOT CONFIGURED: INFINITE ‚ùå)

### Failure Scenario

```
1. Program calls Alpaca API (e.g., get_positions())
2. TCP connection succeeds within 10 seconds ‚úÖ
3. Alpaca's server accepts connection but is slow/stalled responding
   (high load, rate limiting, internal issues, etc.)
4. Program waits FOREVER for response body ‚ùå
5. Main loop is blocked (single-threaded)
6. EOD liquidation never executes
```

## Evidence

From `src/alpaca_client.cxx`, all API methods only set connection timeout:

```cpp
// Lines 194-195, 218-219, 242-243, etc.
auto client = httplib::Client{base_url_};
client.set_connection_timeout(10);  // Only connection timeout!
// Missing: client.set_read_timeout(30);
```

Checked all API methods - **NONE** set read timeout:

- `get_account()` - no read timeout
- `get_positions()` - no read timeout
- `get_open_orders()` - no read timeout
- `get_all_orders()` - no read timeout (has 30s connection timeout)
- `place_order()` - no read timeout
- `cancel_order()` - no read timeout
- `close_position()` - no read timeout
- `get_stock_bars()` - no read timeout (has 30s connection timeout)
- `get_crypto_bars()` - no read timeout (has 30s connection timeout)

## Impact Analysis

### Primary Impact

- Program can freeze at **ANY API call** during operation
- No graceful degradation or error handling
- Completely blocks main event loop (single-threaded design)
- Misses critical time-sensitive operations (EOD liquidation)

### Financial Risk

- Open positions left unmanaged during freeze
- EOD liquidation failure forces manual intervention
- Risk of holding positions overnight (against strategy design)
- After-hours gap risk if manual close fails

### Operational Risk

- Requires human monitoring to detect freeze
- Manual intervention needed under time pressure
- Could miss important exit signals during freeze period
- Log analysis difficult (no "hung" detection or warnings)

## Recommended Fix

### Immediate (Required)

Add read timeouts to all HTTP client instances in `src/alpaca_client.cxx`:

```cpp
auto client = httplib::Client{base_url_};
client.set_connection_timeout(10);  // Connection establishment
client.set_read_timeout(30);         // Response body reading (NEW)
```

### Recommended Timeout Values

**Fast critical operations** (15-30s read timeout):

- `get_positions()` - 30s
- `get_open_orders()` - 30s
- `get_account()` - 30s
- `place_order()` - 15s (fail fast for order placement)
- `cancel_order()` - 15s (fail fast)
- `close_position()` - 15s (fail fast)

**Slow bulk operations** (60s read timeout):

- `get_all_orders()` - 60s (large response)
- `get_stock_bars()` - 60s (historical data)
- `get_crypto_bars()` - 60s (historical data)

### Additional Improvements (Future)

1. **Retry logic with exponential backoff**

   ```cpp
   std::expected<std::string, AlpacaError> retry_api_call(
       auto call_fn, int max_retries = 3) {
     for (int i = 0; i < max_retries; i++) {
       auto result = call_fn();
       if (result) return result;
       std::this_thread::sleep_for(std::chrono::seconds(1 << i));
     }
     return std::unexpected(AlpacaError::Timeout);
   }
   ```

2. **Circuit breaker pattern**
   - Track consecutive API failures
   - Enter "degraded mode" after N failures
   - Skip non-critical operations, focus on position management

3. **Health check heartbeat**
   - Periodic lightweight API call (e.g., get_account every 30s)
   - Log warnings if response time > 5s
   - Detect connectivity issues proactively

4. **Async/non-blocking architecture**
   - Move API calls to separate thread pool
   - Main loop continues even if one API call hangs
   - Timeout enforcement at application level, not just HTTP level

5. **Watchdog timer**
   - External process monitors last activity timestamp
   - Restart program if no activity for 2+ minutes
   - Ensures EOD liquidation happens even if main process hangs

## Testing Strategy

1. **Simulate slow API** - Use network throttling tools to test read timeout behaviour
2. **Load testing** - Verify timeouts work under high API load conditions
3. **Failure injection** - Test circuit breaker and retry logic
4. **EOD scenario** - Ensure liquidation executes even with intermittent API issues

## Prevention Checklist

- [ ] Add `set_read_timeout()` to all HTTP clients in `alpaca_client.cxx`
- [ ] Test read timeout enforcement under simulated network delays
- [ ] Add logging for slow API responses (>5s warning, >10s error)
- [ ] Implement retry logic for non-order-placement operations
- [ ] Add circuit breaker for repeated API failures
- [ ] Create health check monitoring
- [ ] Document timeout values in code comments
- [ ] Add integration tests for timeout scenarios
